{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Merge sort\n",
    "Merge sort was the next development.\n",
    "\n",
    "Invented in 1945 by [John von Neumann](https://en.wikipedia.org/wiki/John_von_Neumann), it too could run on tape where memory was at a premium or the amount to be sorted was too large. \n",
    "While memory inefficient compared to some other sorting algorithms, it can still come out ahead when dealing with slow\n",
    "to access data. It is also very efficient on large data sets.\n",
    "\n",
    "Divide and conquer is the aim here. Say we take a list of 8 random numbers.\n",
    "\n",
    "![mergeSortCropped](https://raw.githubusercontent.com/RobinsonLuzo/Algorithms-Data-Structures/master/img/merge-sort-figure-cropped.jpg)\n",
    "\n",
    "We can subdivide this list into sublists all the way down until we end up with just 2 numbers. \n",
    "We can then compare these 2, swap them if needed, then combine them with the next set that is sorted.\n",
    "\n",
    "It may help if you think of it as taking place from the leftmost, then working up a level and resolving whatever was\n",
    "on the right of that junction, before taking the result as our left \"node\" and moving up a level again until we\n",
    "have a result.\n",
    "\n",
    "![https://github.com/RobinsonLuzo/Algorithms-Data-Structures/blob/master/img/merge-sort-figure.png)\n",
    "\n",
    "[MergeSort](https://stanford.edu/class/archive/cs/cs106b/cs106b.1158/images/merge-sort-figure.png)\n",
    "Taken from Stanford CS106B: Programming Abstractions\n",
    "\n",
    "Merge sort does *log n* steps because each *merge* step doubles the list size.\n",
    "It also does *n* for each *merge* step as it has to look at every item.\n",
    "\n",
    "Total running time is thus: *O(n log n)*, space is: *O(n)*\n",
    "\n",
    "There are 2 functions involved in this algorithm:\n",
    "1. merge() - this is used for merging 2 arrays\n",
    "2. mergeSort() - this calls itself to divide the array until its size becomes one\n",
    "\n",
    "The implementation below is known as a [Top-down Merge sort](https://en.wikipedia.org/wiki/Merge_sort#Top-down_implementation)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.0\n",
      "[-4, 7, 12, 18, 22, 31, 42, 58]\n"
     ]
    }
   ],
   "source": [
    "# mergeSort.py\n",
    "\n",
    "\n",
    "def mergeSort(array):\n",
    "    if len(array) < 2:\n",
    "        return array\n",
    "    else:\n",
    "        middle = len(array)//2 # Int division to force a whole number\n",
    "        left = mergeSort(array[:middle])\n",
    "        right = mergeSort(array[middle:])\n",
    "        return merge(left, right)\n",
    "        \n",
    "        \n",
    "def merge(left, right):\n",
    "    \"\"\" Assumes left and right are sorted arrays/lists \"\"\"\n",
    "    result = []\n",
    "    i, j = 0, 0\n",
    "    while i < len(left) and j < len(right):\n",
    "        if left[i] < right[j]:\n",
    "            result.append(left[i])\n",
    "            i += 1\n",
    "        else:\n",
    "            result.append(right[j])\n",
    "            j += 1\n",
    "    \n",
    "    # Check for any left over items\n",
    "    while i < len(left):\n",
    "        result.append(left[i])\n",
    "        i += 1\n",
    "    while j < len(right):\n",
    "        result.append(right[j])\n",
    "        j += 1\n",
    "    \n",
    "    return result\n",
    "\n",
    "\n",
    "\"\"\" Test case \"\"\"\n",
    "import time     \n",
    "start = time.time()\n",
    "a = [22, 18, 12, -4, 58, 7, 31, 42]\n",
    "mergeSort(a)\n",
    "print((time.time() - start))\n",
    "print(mergeSort(a))  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The version below includes some notation that should make it clearer what is going on\n",
    "as the algorithm steps through the process"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      " Primitive value:  [22]\n",
      " Primitive value:  [18]\n",
      "\t To sort and merge:  [22] [18]\n",
      "\t\t New Sorted array:  [18, 22]\n",
      " Primitive value:  [12]\n",
      " Primitive value:  [-4]\n",
      "\t To sort and merge:  [12] [-4]\n",
      "\t\t New Sorted array:  [-4, 12]\n",
      "\t To sort and merge:  [18, 22] [-4, 12]\n",
      "\t\t New Sorted array:  [-4, 12, 18, 22]\n",
      " Primitive value:  [58]\n",
      " Primitive value:  [7]\n",
      "\t To sort and merge:  [58] [7]\n",
      "\t\t New Sorted array:  [7, 58]\n",
      " Primitive value:  [31]\n",
      " Primitive value:  [42]\n",
      "\t To sort and merge:  [31] [42]\n",
      "\t\t New Sorted array:  [31, 42]\n",
      "\t To sort and merge:  [7, 58] [31, 42]\n",
      "\t\t New Sorted array:  [7, 31, 42, 58]\n",
      "\t To sort and merge:  [-4, 12, 18, 22] [7, 31, 42, 58]\n",
      "\t\t New Sorted array:  [-4, 7, 12, 18, 22, 31, 42, 58]\n",
      "\n",
      "Final Result: [-4, 7, 12, 18, 22, 31, 42, 58]\n"
     ]
    }
   ],
   "source": [
    "# mergeSort.py\n",
    "\n",
    "\n",
    "def mergeSort(array):\n",
    "    level = 0\n",
    "    if len(array) < 2:\n",
    "        print(\"\\t\"*level, \"Primitive value: \", array)\n",
    "        return array\n",
    "    else:\n",
    "        middle = len(array)//2 # Int division to force a whole number\n",
    "        left = mergeSort(array[:middle])\n",
    "        right = mergeSort(array[middle:])\n",
    "        level += 1\n",
    "        print(\"\\t\"*level, \"To sort and merge: \", left, right)\n",
    "        return merge(left, right, level + 1)\n",
    "        \n",
    "        \n",
    "def merge(left, right, level):\n",
    "    \"\"\" Assumes left and right are sorted arrays/lists \"\"\"\n",
    "    result = []\n",
    "    i, j = 0, 0\n",
    "    while i < len(left) and j < len(right):\n",
    "        if left[i] < right[j]:\n",
    "            result.append(left[i])\n",
    "            i += 1\n",
    "        else:\n",
    "            result.append(right[j])\n",
    "            j += 1\n",
    "    \n",
    "    # Check for any left over items\n",
    "    while i < len(left):\n",
    "        result.append(left[i])\n",
    "        i += 1\n",
    "    while j < len(right):\n",
    "        result.append(right[j])\n",
    "        j += 1\n",
    "    print(\"\\t\"*level, \"New Sorted array: \", result)\n",
    "    return result\n",
    "\n",
    "\n",
    "\"\"\" Test case \"\"\"\n",
    "a = [22, 18, 12, -4, 58, 7, 31, 42]\n",
    "print(\"\\nFinal Result: {}\".format(mergeSort(a)))  "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
